会话技术
用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。

会话跟踪
一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据

会话跟踪方案
  客户端会话跟踪技术：Cookie
  服务端会话跟踪技术：Session
  令牌技术

客户端会话跟踪
    //设置Cookie
    @GetMapping("/c1")
    public Result cookiel(HttpServletResponse respones) {
        respones.addCookie(new Cookie("login_username", "itheima"));
        return Result.success();
    }

    //获取Cookie
    @GetMapping("/c2")
    public Result cookie2(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        for (Cookie cookie : cookies) {
            if(cookie.getName().equals("login_username")) {
                System.out.println("login_username: " + cookie.getValue());
            }
        }
        return  Result.success();
    }

    优点
      HTTP协议中跟踪的技术
    缺点
      移动端APP无法使用Cookie
      不安全，用户可以自己禁用Cookie
      Cookie不能跨域


服务端会话跟踪

    //往HttpSession中存储数据
    @GetMapping("/s1")
    public Result Session(HttpSession session) {
        log.info("HttpSession-s1: {}", session.hashCode());
        session.setAttribute("loginUser", "tom");
        return Result.success();
    }

    //从HttpSession中获取数据
    @GetMapping("/s2")
    public Result Session2(HttpServletRequest request) {
        HttpSession session = request.getSession();
        log.info("HttpSession-s2: {}", session.hashCode());

        Object loginUser = session.getAttribute("loginUser");
        log.info("loginUser: {}", loginUser);
        return  Result.success(loginUser);
    }

优点
      存储在服务端，安全
缺点
      服务器集群环境下无法直接使用Session
      Cookie的缺点

令牌技术
  优点
      支持pc端、移动端
      解决集群环境下无法直接使用Session
      减轻服务端存储压力
  缺点
      需要自己实现

JWT令牌
  第一部分：Header,记录令牌类型、签名算法等
  第二部分：payload，携带一些自定义信息
  第三部分：signature,防止Token被篡改、确保安全性。将header、payload加入指定密钥，通过指定签名算法计算而来

    //生成JWT
    @Test
    public void testGenJwt() {
        Map<String,Object> claims = new HashMap<>();
        claims.put("id",1);
        claims.put("name","tom");

        SecretKey key = Keys.hmacShaKeyFor("itheima-itheima-itheima-itheima-1".getBytes());

        String jwt = Jwts.builder()
                .signWith(key,SignatureAlgorithm.HS256)//签名算法
                .setClaims(claims)//自定义内容（荷载）
                .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000))//设置有效期为一小时
                .compact();
        System.out.println(jwt);
    }

    //解析JWT
    @Test
    public void testParseJwt() {
        SecretKey key = Keys.hmacShaKeyFor("itheima-itheima-itheima-itheima-1".getBytes());

        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
            .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTc1MzcxNzg4OX0.gBDirvzvXtCopCUIgJDBAbXpbsj8YYXloSdbJZGZKhQ")
                .getBody();

        System.out.println(claims); // 输出payload部分
    }
  
